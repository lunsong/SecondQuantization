import Mathlib.Data.Complex.Basic
import Mathlib.RingTheory.Ideal.Span
import Mathlib.RingTheory.TwoSidedIdeal.Basic
import Mathlib.RingTheory.TwoSidedIdeal.Operations
import Mathlib.RingTheory.Ideal.Quotient.Defs
import Mathlib.RingTheory.Ideal.Quotient.Operations
import Mathlib.Algebra.Star.Free
import Mathlib.Algebra.FreeAlgebra
import Mathlib.Algebra.Polynomial.Basic
import Mathlib.Algebra.Polynomial.AlgebraMap
import Mathlib.LinearAlgebra.Dimension.Finrank
import Mathlib.Analysis.InnerProductSpace.Defs
import Mathlib.Data.Finsupp.Pointwise
import Mathlib.Analysis.Normed.Lp.WithLp

/-!

# Basic definitions for operators in second quantization

The operators are defined as the quotient of the free algebra generated by creation and
annihilation operators by the commutation relations. The Fock space, which represent the
physical state, is defined as the quotient of the operators by the annihilating operators,
which are the operators that start with an annihilation operator. We can represent the operators
as linear maps over fock states. Vacuum expectation is then defined using this representation.

## Definitions

* `Fock.Operator` is the type of creation and annihilation operators
* `Fock.cre` and `Fock.ann` are the creation and annihilation operators
* `Fock` represent the Fock space
* `Fock.Representation` is the representation of operators as a linear map
* `vacExpect` is the vacuum expectation value of an operator

-/

namespace Fock

/-- `CreAnn` is the type of the free operators -/
inductive CreAnn (α : Type) : Type
  | cre : α → CreAnn α
  | ann : α → CreAnn α

/-- `cre₀ a` is the creation free operator with index `a` -/
abbrev cre₀ {α : Type} (x : α) : FreeAlgebra ℝ (CreAnn α) := FreeAlgebra.ι ℝ (CreAnn.cre x)

/-- `ann₀ a` is the annihilation free operator with index `a` -/
abbrev ann₀ {α : Type} (x : α) : FreeAlgebra ℝ (CreAnn α) := FreeAlgebra.ι ℝ (CreAnn.ann x)

notation (name := anticommute) "[" a "," b "]ₐ" => a * b + b * a

/-- `commutators` is the set of commutation relations -/
abbrev commutators (α : Type) : Set (FreeAlgebra ℝ (CreAnn α)) := fun x =>
  ( ∃ a b, x = [cre₀ a, cre₀ b]ₐ ∨ x = [ann₀ a, ann₀ b]ₐ ∨ ( a ≠ b ∧ x = [ann₀ a, cre₀ b]ₐ)) ∨
  ( ∃ a, x = [ann₀ a, cre₀ a]ₐ - 1)

/-- `Operator α` is the type of creation and annihilation operators with `α` be the index type -/
abbrev Operator (α : Type) : Type :=
  (FreeAlgebra ℝ (CreAnn α)) ⧸ (TwoSidedIdeal.span (commutators α)).asIdeal

/-- `cre a` is the creation operator with index `a` -/
abbrev cre {α : Type} (x : α) : Operator α := Ideal.Quotient.mk _ (cre₀ x)

/-- `ann a` is the annihilation operator with index `a` -/
abbrev ann {α : Type} (x : α) : Operator α := Ideal.Quotient.mk _ (ann₀ x)

/-- anti-commutation between creation operators -/
theorem cre_cre {α : Type} (x y : α) : cre x * cre y = -(cre y * cre x) := by
  apply eq_neg_iff_add_eq_zero.mpr
  rw[←RingHom.map_mul,←RingHom.map_mul,←RingHom.map_add,←(Ideal.Quotient.mk _).map_zero,
    Ideal.Quotient.mk_eq_mk_iff_sub_mem, sub_zero]
  apply TwoSidedIdeal.subset_span
  left
  use x,y
  left; rfl

/-- anti-commutation between annihilation operators -/
theorem ann_ann {α : Type} (x y : α) : ann x * ann y = -(ann y * ann x) := by
  apply eq_neg_iff_add_eq_zero.mpr
  rw[←RingHom.map_mul,←RingHom.map_mul,←RingHom.map_add,←(Ideal.Quotient.mk _).map_zero,
    Ideal.Quotient.mk_eq_mk_iff_sub_mem, sub_zero]
  apply TwoSidedIdeal.subset_span
  left
  use x,y
  right; left; rfl

/-- anti-commutation between creation and annihilation operators of different indices -/
theorem ann_cre_ne {α : Type} (x y : α) : x ≠ y → ann x * cre y = -(cre y * ann x) := by
  intro h
  apply eq_neg_iff_add_eq_zero.mpr
  rw[←RingHom.map_mul,←RingHom.map_mul,←RingHom.map_add, ←(Ideal.Quotient.mk _).map_zero,
    Ideal.Quotient.mk_eq_mk_iff_sub_mem, sub_zero]
  apply TwoSidedIdeal.subset_span
  left
  use x,y
  right; right; exact ⟨h, rfl⟩

/-- anti-commutation between creation and annihilation operators of same index -/
theorem ann_cre {α : Type} (x : α) :  ann x * cre x = 1 - (cre x * ann x) := by
  apply eq_sub_of_add_eq
  apply eq_of_sub_eq_zero
  rw[←RingHom.map_mul,←RingHom.map_mul,←RingHom.map_add,←(Ideal.Quotient.mk _).map_zero,
    ←(Ideal.Quotient.mk _).map_one,sub_eq_add_neg,←RingHom.map_neg,←RingHom.map_add,
    Ideal.Quotient.mk_eq_mk_iff_sub_mem, sub_zero,←sub_eq_add_neg]
  apply TwoSidedIdeal.subset_span
  right
  use x

/-- Operators can be represented as a linear map over fock states -/
abbrev Representation (α : Type) : Type := (Finset α →₀ ℝ) →ₗ[ℝ] (Finset α →₀ ℝ)

namespace Representation

noncomputable section

/-- When an operator `x` is multiplied by either a creation or an annihilation operator `a`,
we need to first move `a` to its corresponding position using the commutation relations. The sign
generated in this process is `commutation_sign` -/
def commutator_sign {α : Type} [LinearOrder α] (s : Finset α) (a : α) : ℝ :=
  if Even (Finset.filter (· < a) s).card then 1 else -1

theorem commutator_sign_range {α : Type} [LinearOrder α] (s : Finset α) (a : α) :
    commutator_sign s a = 1 ∨ commutator_sign s a = -1 := by
  dsimp [commutator_sign]
  by_cases h : Even {x ∈ s | x < a}.card
  · simp[h]
  · simp[h]

theorem commutator_sign_diff {α : Type} [LinearOrder α] (s : Finset α) (a b : α) :
    commutator_sign (s \ {a}) b =
      if a < b ∧ a ∈ s then -commutator_sign s b else commutator_sign s b := by
  split
  · dsimp only [commutator_sign]
    rename_i h
    have : Finset.filter (· < b) s = (Finset.filter (· < b) (s \ {a})) ∪ {a} := by
      ext x
      constructor
      · simp +contextual [Classical.em]
      · simp 
        intro h'
        rcases h' with h' | h'
        · simp[h',h]
        · simp[h']
    have := congrArg Finset.card this
    rw[Finset.card_union, show {x ∈ s \ {a} | x < b} ∩ {a} = ∅ by simp,
       Finset.card_singleton, Finset.card_empty,Nat.sub_zero] at this
    rw[this]
    simp only [Nat.even_add_one]
    by_cases heven : Even {x ∈ s \ {a} | x < b}.card
    · simp[heven]
    · simp[heven]
  · rename_i h
    dsimp only [commutator_sign]
    have : Finset.filter (· < b) s = Finset.filter (· < b) (s \ {a}) := by   
      ext x
      simp
      intro  h₁ h₂ h₃
      exact h ⟨h₃ ▸ h₁, h₃ ▸ h₂⟩
    rw[this]

theorem commutator_sign_union {α : Type} [LinearOrder α] (s : Finset α) (a b : α) :
    commutator_sign (s ∪ {a}) b =
      if a < b ∧ a ∉ s then -commutator_sign s b else commutator_sign s b := by
  split
  · rename_i h
    dsimp only [commutator_sign]
    have : Finset.filter (· < b) (s ∪ {a}) = (Finset.filter (· < b) s) ∪ {a} := by
      ext x
      constructor
      · simp +contextual
      · simp
        intro h'
        rcases h' with h' | h'
        · simp[h',h]
        · simp[h']
    rw[this,Finset.card_union]
    have : {x ∈ s | x < b} ∩ {a} = (∅ : Finset α) := by
      ext x
      simp
      intro h₁ _ h₂
      exact h.2 (h₂ ▸ h₁)
    rw[this,Finset.card_empty,Finset.card_singleton,Nat.sub_zero]
    simp only [Nat.even_add_one]
    by_cases heven : Even ({x ∈ s | x < b}.card)
    · simp [heven]
    · simp [heven]
  · rename_i h
    dsimp only [commutator_sign]
    have : Finset.filter (· < b) s = Finset.filter (· < b) (s ∪ {a}) := by   
      ext x
      simp at h ⊢
      exact fun a b ↦ (b ▸ h) a
    rw[this]

def cre {α : Type} [LinearOrder α] (i : α) : Representation α where
  toFun x := {
    toFun s := if i ∉ s then 0 else x (s \ {i}) * commutator_sign s i
    support := Finset.image (fun s ↦ s ∪ {i}) (Finset.filter (i ∉ ·) x.support) 
    mem_support_toFun s := by
      simp [-Finset.union_singleton]
      constructor
      · intro ⟨s',⟨h₁,h₂⟩⟩
        split_ands
        · simp[←h₂]
        · simp[←h₂,-Finset.union_singleton] 
          rw[Finset.union_sdiff_cancel_right]
          · exact h₁.1
          · simp[h₁.2]
        rcases commutator_sign_range s i with h | h
        all_goals simp[h]
      intro ⟨h₁,h₂,_⟩
      use s \ {i}
      simpa[h₂,-Finset.union_singleton]
  }
  map_add' x y := by
    ext s
    simp[commutator_sign]
    split_ifs
    · rfl
    · rw[add_comm]
    · norm_num
  map_smul' m x := by
    ext s
    simp[commutator_sign]

def ann {α : Type} [LinearOrder α] (i : α) : Representation α where
  toFun x := {
    toFun s := if i ∈ s then 0 else x (s ∪ {i}) * commutator_sign s i
    support := Finset.image (fun s ↦ s \ {i}) (Finset.filter (i ∈ ·) x.support) 
    mem_support_toFun s := by
      simp[-Finset.union_singleton]
      constructor
      · intro ⟨a, ⟨h₁, h₂⟩, h₃⟩
        split_ands
        · simp[←h₃]
        · rwa[←h₃,Finset.sdiff_singleton_eq_erase,Finset.union_singleton,Finset.insert_erase h₂]
        · rcases commutator_sign_range s i with h | h
          all_goals simp[h]
      · intro ⟨h₁, h₂, _⟩
        use s ∪ {i}
        simp[h₂,-Finset.union_singleton]
        rw[Finset.union_sdiff_cancel_right]
        simpa
  }
  map_add' x y := by
    ext s
    simp[commutator_sign]
    split_ifs
    · norm_num
    · rfl
    · rw[add_comm]
  map_smul' m x := by
    ext s
    simp[commutator_sign]

def ofAux₀ {α : Type} [LinearOrder α] : CreAnn α → Representation α
  | CreAnn.cre i => cre i
  | CreAnn.ann i => ann i

def ofAux₁ {α : Type} [LinearOrder α] : FreeAlgebra ℝ (CreAnn α) →ₐ[ℝ] Representation α :=
  FreeAlgebra.lift ℝ ofAux₀

theorem ofAux₁_commutators {α : Type} [LinearOrder α] : ∀ x ∈ commutators α, ofAux₁ x = 0 := by
  intro x h
  rcases h with ⟨a, b, h | h | h⟩ | ⟨a, h⟩
  · ext x s
    simp[ofAux₁,h,ofAux₀,cre,commutator_sign_diff]
    by_cases ha : a ∈ s
    · by_cases hb : b ∈ s
      · by_cases h : a < b
        · simp[h,ha,hb,h.ne,show b ≠ a from h.ne ∘ Eq.symm, show ¬(b < a) from h.asymm]
          conv =>
            lhs; arg 1
            rw[sdiff_sdiff_comm, mul_assoc, mul_comm (commutator_sign s b),←mul_assoc]
          exact neg_add_cancel _
        by_cases h' : a = b
        · simp[h']
        have h'' : b < a := lt_of_le_of_ne (le_of_not_gt h) (h' ∘ Eq.symm)
        simp[h,h',h'',ha,hb,show b ≠ a from h'∘Eq.symm]
        conv =>
          lhs; arg 1
          rw[sdiff_sdiff_comm, mul_assoc, mul_comm (commutator_sign s b),←mul_assoc]
        exact add_neg_cancel _
      · simp[ha,hb]
    · simp[ha]
  · ext x s
    simp[ofAux₁,h,ofAux₀,ann,-Finset.union_singleton,-Finset.singleton_union]
    by_cases ha : a ∈ s
    · simp[ha]
    by_cases hb : b ∈ s
    · simp[hb]
    by_cases h : a = b
    · simp[h]
    by_cases h' : a < b
    · simp[ha,hb,h,show b ≠ a from h ∘ Eq.symm, commutator_sign_union, -Finset.union_singleton,
           h',show ¬ b < a from h'.asymm,-Finset.singleton_union]
      ac_nf
      exact neg_add_cancel _
    have h'' : b < a := lt_of_le_of_ne (le_of_not_gt h') (h ∘ Eq.symm)
    simp[h,ha,hb,show b ≠ a from h ∘ Eq.symm, -Finset.union_singleton,-Finset.singleton_union,
         commutator_sign_union,h',h'']
    ac_nf
    exact neg_add_cancel _
  · ext x s
    simp[ofAux₁,h.2,ofAux₀,cre,ann,-Finset.union_singleton,-Finset.singleton_union]
    by_cases ha : a ∈ s
    · simp[ha,h.1]
    by_cases hb : b ∈ s
    · simp[ha,hb,h.1,-Finset.union_singleton,-Finset.singleton_union,
           commutator_sign_union,commutator_sign_diff]
      have : (s ∪ {a}) \ {b} = (s \ {b} ∪ {a}) := by
        ext x
        constructor
        · simp +contextual
        · simp
          intro h''
          rcases h'' with h'' | h''
          · exact ⟨Or.inl h'', h'' ▸ h.1⟩
          · exact ⟨Or.inr h''.1, h''.2⟩
      by_cases h' : a < b
      · simp[h',show ¬ b < a from h'.asymm,-Finset.union_singleton]
        rw[this]
        ring
      have h'' : b < a := lt_of_le_of_ne (le_of_not_gt h') (h.1 ∘ Eq.symm)
      simp[h',h'',-Finset.union_singleton]
      rw[this]
      ring
    · simp[ha,hb,show b ≠ a from h.1 ∘ Eq.symm]
  · ext x s
    simp[ofAux₁,h,ofAux₀,cre,ann,-Finset.union_singleton,-Finset.singleton_union]
    have : commutator_sign s a * commutator_sign s a = 1 := by
      by_cases h : Even {x ∈ s | x < a}.card
      · simp[commutator_sign,h]
      · simp[commutator_sign,h]
    by_cases ha : a ∈ s
    · simp[ha,commutator_sign_diff]
      rw[mul_assoc,this,mul_one,sub_self]
    simp[ha,-Finset.union_singleton,commutator_sign_union]
    rw[Finset.union_sdiff_cancel_right,mul_assoc,this,mul_one,sub_self]
    simpa


/-- Operators can be represented as a linear map over fock states -/
def of {α : Type} [LinearOrder α] : Operator α →ₐ[ℝ] Representation α :=
  Ideal.Quotient.liftₐ _ ofAux₁ (by
    intro a h
    rw[←TwoSidedIdeal.mem_ker]
    rw[TwoSidedIdeal.mem_asIdeal] at h
    suffices final : TwoSidedIdeal.span (commutators α) ≤ TwoSidedIdeal.ker ofAux₁ from final h
    rw[TwoSidedIdeal.span_le]
    intro x h
    simp[TwoSidedIdeal.ker]
    exact ofAux₁_commutators x h
  )

end

end Representation

/-- 1 ≠ 0 for `Operator` -/
instance instNeZeroOne {α : Type} [LinearOrder α] : NeZero (1 : Operator α) where
  out := by
    intro h
    have repr0 : Representation.of (0 : Operator α) = 0 := by simp[Representation.of]
    have repr1 : Representation.of (1 : Operator α) = 1 := by simp[Representation.of]
    replace h := repr0 ▸ repr1 ▸ (congrArg Representation.of h)
    simp at h

/-- The injectivity of `cre` -/
theorem cre_inj {α : Type} [LinearOrder α] : Function.Injective (@cre α) := by
  intro x y h
  by_contra! hc
  have := (ann_cre _) ▸ h ▸ (ann_cre_ne _ _ hc)
  rw[sub_eq_iff_eq_add,neg_add_cancel] at this
  simp at this

/-- The injectivity of `ann` -/
theorem ann_inj {α : Type} [LinearOrder α] : Function.Injective (@ann α) := by
  intro x y h
  by_contra! hc
  have := (ann_cre _) ▸ h ▸ (ann_cre_ne _ _ hc)
  rw[sub_eq_iff_eq_add,neg_add_cancel] at this
  simp at this

namespace conjugation

def conjAux₀ {α : Type} : CreAnn α → CreAnn α
  | CreAnn.cre x => CreAnn.ann x
  | CreAnn.ann x => CreAnn.cre x

lemma conjAux₀_involutive {α : Type} : ∀ x : CreAnn α, conjAux₀ (conjAux₀ x) = x
  | CreAnn.cre x => by simp only [conjAux₀]
  | CreAnn.ann x => by simp only [conjAux₀]

def conjAux₁ {α : Type} : (FreeAlgebra ℝ (CreAnn α)) →ₐ[ℝ] (FreeAlgebra ℝ (CreAnn α))ᵐᵒᵖ :=
  FreeAlgebra.lift ℝ (MulOpposite.op ∘ FreeAlgebra.ι ℝ ∘ conjAux₀)

def conjAux₂ {α : Type} : (FreeAlgebra ℝ (CreAnn α)) → Operator α :=
  Ideal.Quotient.mk _ ∘ MulOpposite.unop ∘ conjAux₁

/-- The conjugation of operators -/
def conj {α : Type} : Operator α → Operator α :=
  Quotient.lift conjAux₂ (by
    intro a b h
    rw[←Quotient.eq_iff_equiv] at h
    have : (Ideal.Quotient.mk _ a : Operator α) = Ideal.Quotient.mk _ b := by
      simpa [←Ideal.Quotient.mk_eq_mk, Submodule.Quotient.mk]
    simp only [conjAux₂,Function.comp_apply,Ideal.Quotient.mk_eq_mk_iff_sub_mem] at this ⊢
    rw [←MulOpposite.unop_sub, ←map_sub]
    rw [TwoSidedIdeal.mem_asIdeal] at this
    generalize a - b = x at this ⊢
    refine TwoSidedIdeal.span_induction ?_ ?_ ?_ ?_ ?_ ?_ this
    · intro x h
      rw [TwoSidedIdeal.mem_asIdeal]
      apply TwoSidedIdeal.subset_span
      rcases h with h | h
      · rcases h with ⟨a, b, h | h | h⟩
        · simp[h,conjAux₁,conjAux₀]; left; use b,a; right; left; rfl
        · simp[h,conjAux₁,conjAux₀]; left; use b,a; left; rfl
        · simp[h.2,conjAux₁,conjAux₀]; left; use b,a; right; right; exact ⟨h.1.symm, rfl⟩
      obtain ⟨a, h⟩ := h
      simp[h, conjAux₁, conjAux₀]; right; use a
    · simp only [map_zero, MulOpposite.unop_zero, zero_mem]
    · intro x y _ _ h₁ h₂
      rw[map_add,MulOpposite.unop_add]
      exact Ideal.add_mem _ h₁ h₂
    · intros
      rwa[map_neg,MulOpposite.unop_neg,Ideal.neg_mem_iff]
    · intro x y _ h
      rw[map_mul,MulOpposite.unop_mul]
      exact TwoSidedIdeal.mul_mem_right _ _ _ h
    · intro x y _ h
      rw[map_mul,MulOpposite.unop_mul]
      exact TwoSidedIdeal.mul_mem_left _ _ _ h
  )

theorem mk_eq_mk {α : Type} (a : FreeAlgebra ℝ (CreAnn α)) :
    (Ideal.Quotient.mk _ a: Operator α) = ⟦a⟧ := rfl

set_option synthInstance.maxHeartbeats 30000 in 
-- This is needed otherwise lean will fail to synthesize AddHomClass for Ideal.Quotient.mk
instance operatorStarRing (α : Type) : StarRing (Operator α) where
  star := conj
  star_involutive x := by
    refine Submodule.Quotient.induction_on _ x ?_
    intro x
    rw[Submodule.Quotient.mk]
    simp[conj,conjAux₂,←Ideal.Quotient.mk_eq_mk,Submodule.Quotient.mk]
    congr 1
    refine FreeAlgebra.induction _ _ ?_ ?_ ?_ ?_ x
    · simp
    · simp[conjAux₁,conjAux₀_involutive]
    · simp +contextual
    · simp +contextual
  star_add := by
    apply Quotient.ind₂
    intro a b
    rw[←mk_eq_mk,←mk_eq_mk,←map_add,mk_eq_mk,mk_eq_mk, mk_eq_mk]
    simp [conj,Quotient.lift_mk,conjAux₂]
  star_mul := by
    apply Quotient.ind₂
    intro a b
    rw [←mk_eq_mk,←mk_eq_mk,←map_mul,mk_eq_mk,mk_eq_mk, mk_eq_mk,
      conj,Quotient.lift_mk,Quotient.lift_mk,Quotient.lift_mk]
    simp[conjAux₂]

end conjugation

open conjugation in
/-- the conjugation of `cre x` is `ann x` -/
theorem star_cre {α : Type} (x : α) : star (cre x) = ann x := by
  simp[star,conj,mk_eq_mk,conjAux₂,conjAux₁,conjAux₀]

open conjugation in
/-- the conjugation of `ann x` is `cre x` -/
theorem star_ann {α : Type} (x : α) : star (ann x) = cre x := by
  simp[star,conj,mk_eq_mk,conjAux₂,conjAux₁,conjAux₀]

def vacuum_ideal {α : Type} : Ideal (Operator α) := Ideal.span (Set.range ann)

def vacuum_submodule {α : Type} : Submodule ℝ (Operator α) := vacuum_ideal.restrictScalars _

set_option synthInstance.maxHeartbeats 30000 in
-- This is needed otherwise lean will fail to synthesize AddHomClass for Ideal.Quotient.mk
/-- `star` as a linear map -/
def starₗ {α : Type} : Operator α →ₗ[ℝ] Operator α where
  toFun := star
  map_add' x y := by simp
  map_smul' m := by
    apply Quotient.ind
    intro a
    rw[←conjugation.mk_eq_mk,←Ideal.Quotient.mkₐ_eq_mk ℝ, ←map_smul,Ideal.Quotient.mkₐ_eq_mk,
      conjugation.mk_eq_mk,conjugation.mk_eq_mk,RingHom.id_apply]
    simp[star,conjugation.conj,conjugation.conjAux₂]
    rw[←Ideal.Quotient.mkₐ_eq_mk ℝ,map_smul]

theorem starₗ_apply {α : Type} (x : Operator α) : starₗ x = star x := by simp[starₗ]
    
namespace Operator

abbrev ofReal {α : Type} : ℝ →+* Operator α := algebraMap ℝ (Operator α)

end Operator

namespace Representation

open Classical
in noncomputable def expect {α : Type} : Representation α →ₗ[ℝ] ℝ where
  toFun x := x (Finsupp.single ∅ 1) ∅
  map_add' x y := by simp
  map_smul' m x := by simp

end Representation

/-- The vacuum expectation of an operator -/
noncomputable def vacExpect {α : Type} [LinearOrder α] : Operator α →ₗ[ℝ] ℝ :=
  Representation.expect.comp Representation.of.toLinearMap

/-- The vacuum expectation of a scalar is itself -/
theorem vacExpect_ofReal {α : Type} [LinearOrder α] (x : ℝ) :
    vacExpect (Operator.ofReal (α := α) x) = x := by
  simp[vacExpect,Representation.expect]

/-- The vacuum expectation of any operator starting with an annihilation operator is 0 -/
theorem vacExpect_mul_ann {α : Type} [LinearOrder α] (x : Operator α) (a : α) :
    vacExpect (x * ann a) = 0 := by
  simp[vacExpect,Representation.expect]
  open Representation in conv =>
    lhs; arg 1; arg 2
    simp[of,ofAux₁,ofAux₀]
  have : ((Representation.ann a) (Finsupp.single ∅ 1)) = 0 := by
    ext s
    simp[Representation.ann]
  simp[this]

/-- The vacuum expectation of any operator ending with an creation operator is 0 -/
theorem vacExpect_cre_mul {α : Type} [LinearOrder α] (x : Operator α) (a : α) :
    vacExpect (cre a * x) = 0 := by
  simp[vacExpect,Representation.expect]
  open Representation in conv =>
    lhs; arg 1
    simp[of,ofAux₁,ofAux₀,Representation.cre]
  simp

namespace Representation

/-- The `Representation` of `star x` is the adjoint of the `Representation` of `x` -/
theorem of_star {α : Type} [LinearOrder α] (x : Operator α) :
    ∀ s t, of x (Finsupp.single s 1) t = of (star x) (Finsupp.single t 1) s := by
  refine Submodule.Quotient.induction_on _ x ?_
  refine FreeAlgebra.induction _ _ ?_ ?_ ?_ ?_
  · simp
    intro r s t
    rw[←starₗ_apply, Algebra.algebraMap_eq_smul_one]
    simp[starₗ,Finsupp.single_apply]
    grind
  · intro x s t
    match x with
    | CreAnn.cre a =>
      rw[Ideal.Quotient.mk_eq_mk,←Fock.cre, star_cre]
      simp[of,ofAux₁,ofAux₀,cre,ann,Finsupp.single_apply]
      by_cases ha : a ∈ t
      · by_cases hb : a ∈ s
        · have h₁ : s ≠ t \ {a} := by intro hc; simp [hc] at hb
          simp[ha,hb,h₁]
        · by_cases h₁ : t = insert a s
          · have h₁' : s = t \ {a} := by
              rw[h₁,Finset.sdiff_singleton_eq_erase,Finset.erase_insert hb]
            simp only [ha, ↓reduceIte, iff_true_intro h₁', hb, iff_true_intro h₁]
            rw[h₁',commutator_sign_diff]
            simp
          · have h₁' : s ≠ t \ {a} := by
              intro hc
              rw[hc, Finset.sdiff_singleton_eq_erase, Finset.insert_erase ha] at h₁
              exact h₁ rfl
            simp[ha,hb,h₁,h₁']
      · by_cases hb : a ∈ s
        · simp[ha,hb]
        · simp[ha,hb]
          intro hc
          simp[hc] at ha
    | CreAnn.ann a =>
      rw[Ideal.Quotient.mk_eq_mk,←Fock.ann, star_ann]
      simp[of,ofAux₁,ofAux₀,cre,ann,Finsupp.single_apply]
      by_cases ha : a ∈ t
      · by_cases hb : a ∉ s
        · simp[ha,hb]
        have : t ≠ s \ {a} := by intro hc; simp[hc] at ha
        simp[ha,this]
      · by_cases h₁ : s = insert a t
        · simp[ha,h₁]
          rw[Finset.sdiff_singleton_eq_erase,Finset.erase_insert ha, ←Finset.union_singleton,
            commutator_sign_union]
          simp
        · simp[ha,h₁]
          intro h h'
          rw[h', Finset.sdiff_singleton_eq_erase, Finset.insert_erase h, eq_self, not_true] at h₁
          exact h₁.elim
  · intro a b h₁ h₂ s t
    rw[Ideal.Quotient.mk_eq_mk] at h₁ h₂ ⊢
    rw[map_mul,star_mul,map_mul,map_mul]
    generalize (Ideal.Quotient.mk _ a : Operator α) = A at h₁ ⊢
    generalize (Ideal.Quotient.mk _ b : Operator α) = B at h₂ ⊢
    rw[Module.End.mul_apply, ←Finsupp.sum_single ((of B) (Finsupp.single s 1)),Finsupp.sum,
      map_sum,Finset.sum_apply']
    conv =>
      lhs; arg 2; intro k
      rw[←mul_one (((of B) (Finsupp.single s 1)) k), ←smul_eq_mul, ←Finsupp.smul_single,
        map_smul,Finsupp.smul_apply,h₁,smul_eq_mul]
    generalize hM : ((of B) (Finsupp.single s 1)).support = M
    generalize hN : ((of (star A)) (Finsupp.single t 1)).support = N
    generalize hf :
        (fun k ↦ ((of B) (Finsupp.single s 1)) k * ((of (star A)) (Finsupp.single t 1)) k) = f
    have : M.sum f = (M ∩ N).sum f := by
      refine (Finset.sum_subset Finset.inter_subset_left ?_).symm
      rw[←hM,←hN,←hf]
      intro x h₁ h₂
      rw[Finset.mem_inter,Finsupp.mem_support_iff,Finsupp.mem_support_iff,not_and_or,not_not,
        not_not] at h₂
      simpa
    rw[this]
    have : N.sum f = (M ∩ N).sum f := by
      refine (Finset.sum_subset Finset.inter_subset_right ?_).symm
      rw[←hM,←hN,←hf]
      intro x h₁ h₂
      rw[Finset.mem_inter,Finsupp.mem_support_iff,Finsupp.mem_support_iff,not_and_or,not_not,
        not_not] at h₂
      simpa
    rw[←this,←hN,←hf]
    conv =>
      rhs
      rw[Module.End.mul_apply,←Finsupp.sum_single ((of (star A)) (Finsupp.single t 1)),
        Finsupp.sum,map_sum,Finset.sum_apply']
      arg 2; intro k
      rw[←mul_one (((of (star A)) (Finsupp.single t 1)) k),←smul_eq_mul,←Finsupp.smul_single,
        map_smul,Finsupp.smul_apply,smul_eq_mul,mul_comm,←h₂]
  · intro a b h₁ h₂ s t
    specialize h₁ s t
    specialize h₂ s t
    rw[Ideal.Quotient.mk_eq_mk] at h₁ h₂ ⊢
    rw[←starₗ_apply,map_add,map_add,map_add,map_add,LinearMap.add_apply,Finsupp.add_apply,
      LinearMap.add_apply,Finsupp.add_apply,h₁,h₂,starₗ_apply,starₗ_apply]

end Representation

/-- conjugation does not change expectation -/
theorem vacExpect_star {α : Type} [LinearOrder α] (x : Operator α) :
    vacExpect (star x) = vacExpect x := by
  simp[vacExpect,Representation.expect,←Representation.of_star]

/-- The vacuum expectation of `x * star x` is non-negative -/
theorem vacExpect_mul_star_nonneg {α : Type} [LinearOrder α] (x : Operator α) :
    0 ≤ vacExpect (x * star x) := by
  simp[vacExpect,Representation.expect]
  rw[←Finsupp.sum_single ((Representation.of (star x)) (Finsupp.single ∅ 1)),Finsupp.sum,
    map_sum, Finset.sum_apply']
  conv =>
    rhs; arg 2; intro k
    rw[←Representation.of_star,←mul_one (Representation.of x (Finsupp.single k 1) ∅),
      ←smul_eq_mul,←Finsupp.smul_single,map_smul,Finsupp.smul_apply,smul_eq_mul,←pow_two]
  apply Finset.sum_nonneg
  intro i h
  positivity


notation (name := R3) "ℝ³" => Fin 3 → ℝ

/-- The field operator can be defined after specifying the basis function -/
noncomputable def fieldOp {α : Type} (basis : α → ℝ³ → ℝ) : ℝ³ → Operator α :=
  fun r ↦ ∑ᶠ a : α, basis a r • cre a

/-- The multi-variate field operator -/
noncomputable def fieldOp_multi {α : Type} (basis : α → ℝ³ → ℝ) {n : ℕ} :
    (Fin n → ℝ³) → Operator α :=
  fun r ↦ (List.ofFn ((fieldOp basis) ∘ r)).prod

/-- The `waveFunction` is defined for an *Operator* as the vacuum expectation of the field 
operator multiplies the operator -/
noncomputable def waveFunction {α : Type} [LinearOrder α] (basis : α → ℝ³ → ℝ) (x : Operator α)
  {n : ℕ} (r : Fin n → ℝ³) : ℝ :=
  vacExpect ((fieldOp_multi basis r) * x)

end Fock

abbrev Fock (α : Type) : Type := Fock.Operator α ⧸ Fock.vacuum_ideal

namespace Fock

abbrev FockRepresentation (α : Type) : Type := Finset α →₀ ℝ

namespace FockRepresentation

noncomputable instance operatorModule (α : Type) [LinearOrder α] :
      Module (Operator α) (FockRepresentation α) where
  smul s x := Representation.of s x
  one_smul b := by simp[HSMul.hSMul]
  zero_smul b := by simp[HSMul.hSMul]
  smul_zero a := by simp[HSMul.hSMul]
  smul_add a b c := by simp[HSMul.hSMul]
  add_smul a b c := by simp[HSMul.hSMul]
  mul_smul a b c := by simp[HSMul.hSMul]

noncomputable abbrev ofOperator {α : Type} [LinearOrder α] :
    Operator α →ₗ[Operator α] FockRepresentation α where
  toFun x := Representation.of x (Finsupp.single ∅ 1)
  map_add' x y := by simp
  map_smul' x y := by simp[HSMul.hSMul,SMul.smul]

noncomputable def of {α : Type} [LinearOrder α] :
    Fock α →ₗ[Operator α] FockRepresentation α :=
  Submodule.liftQ vacuum_ideal FockRepresentation.ofOperator (by 
    rw[vacuum_ideal,Ideal.span_le]
    intro x hx
    obtain ⟨a, ha⟩ := Set.mem_range.mp hx
    ext s
    open Representation in simp[←ha,Representation.of,ofAux₁,ofAux₀,Representation.ann]
  )

end FockRepresentation

def vacuum {α : Type} : Fock α := 1

theorem smul_vacuum {α : Type} (x : Operator α) : x • vacuum = vacuum_ideal.mkQ x := by
  simp[vacuum,HSMul.hSMul,SMul.smul]
  conv =>
    lhs; arg 3
    simp[OfNat.ofNat,One.one]
  simp[Submodule.Quotient.mk]
  congr
  change x * 1 = x
  simp only [mul_one]

noncomputable instance fockInner (α : Type) [LinearOrder α] : Inner ℝ (Fock α) where
  inner x y := (FockRepresentation.of x * FockRepresentation.of y).sum fun _i a ↦ a

open scoped RealInnerProductSpace

/-
theorem inner_eq_vacExpect (α : Type) [LinearOrder α] (a b : Fock α) (x : Operator α) :
    ⟪a, x • b⟫  = ⟪star x • a, b⟫ := by
  conv_rhs =>
    simp only [inner, map_smul]
    simp only [HSMul.hSMul,SMul.smul]
    rw[Finsupp.sum, ←Finsupp.sum_single (FockRepresentation.of b)]
-/


end Fock
