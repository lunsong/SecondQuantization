import Mathlib.Data.Complex.Basic
import Mathlib.RingTheory.Ideal.Span
import Mathlib.RingTheory.TwoSidedIdeal.Basic
import Mathlib.RingTheory.TwoSidedIdeal.Operations
import Mathlib.RingTheory.Ideal.Quotient.Defs
import Mathlib.RingTheory.Ideal.Quotient.Operations
import Mathlib.Algebra.Star.Free
import Mathlib.Algebra.FreeAlgebra
import Mathlib.Algebra.Polynomial.Basic
import Mathlib.Algebra.Polynomial.AlgebraMap
import Mathlib.LinearAlgebra.Dimension.Finrank
import Mathlib.Analysis.InnerProductSpace.Defs
import Mathlib.Data.Finsupp.Pointwise

/-!

# Creation and Annihilation Operators

The operators are defined as the free algebra generated by creation and annihilation operators
quotient by the commutation rules. Currently restricted to ℝ-algebra, since ℂ is not necessary
from a physical perspective, and use discrete indices to avoid the Dirac-delta function.

The Fock space, which represent the physical state, is defined as the operators quotient by the
annihilating operators, which are the operators that start with an annihilation operator.

The expectation value can be obtained by first taking the quotient with respect to the 
annihilating operators and its conjugate, which are operators that end with a creation operator,
then using the theorem that the quotient space has dimension one to extract a real valued
expectation.

## Definitions

* `Fock.Operator` is the type of creation and annihilation operators
* `Fock.cre` and `Fock.ann` are the creation and annihilation operators
* `Fock` represent the Fock space
* `expectVal` is the vacuum expectation value of an operator

-/

namespace Fock

inductive CreAnn (α : Type) : Type
  | cre : α → CreAnn α
  | ann : α → CreAnn α

abbrev cre' {α : Type} (x : α) : FreeAlgebra ℝ (CreAnn α) := FreeAlgebra.ι ℝ (CreAnn.cre x)
abbrev ann' {α : Type} (x : α) : FreeAlgebra ℝ (CreAnn α) := FreeAlgebra.ι ℝ (CreAnn.ann x)

notation (name := anticommute) "[" a "," b "]ₐ" => a * b + b * a

abbrev commutators (α : Type) : Set (FreeAlgebra ℝ (CreAnn α)) := fun x =>
  ( ∃ a b, x = [cre' a, cre' b]ₐ ∨ x = [ann' a, ann' b]ₐ ∨ ( a ≠ b ∧ x = [ann' a, cre' b]ₐ)) ∨
  ( ∃ a, x = [ann' a, cre' a]ₐ - 1)

/-- `Operator α` is the type of creation and annihilation operators with `α` be the index type -/
abbrev Operator (α : Type) : Type :=
  (FreeAlgebra ℝ (CreAnn α)) ⧸ (TwoSidedIdeal.span (commutators α)).asIdeal

/-- `cre a` is the creation operator with index `a` -/
abbrev cre {α : Type} (x : α) : Operator α := Ideal.Quotient.mk _ (cre' x)

/-- `ann a` is the annihilation operator with index `a` -/
abbrev ann {α : Type} (x : α) : Operator α := Ideal.Quotient.mk _ (ann' x)

/-- anti-commutation between creation operators -/
theorem cre_cre {α : Type} (x y : α) : cre x * cre y = -(cre y * cre x) := by
  apply eq_neg_iff_add_eq_zero.mpr
  rw[←RingHom.map_mul,←RingHom.map_mul,←RingHom.map_add,←(Ideal.Quotient.mk _).map_zero,
    Ideal.Quotient.mk_eq_mk_iff_sub_mem, sub_zero]
  apply TwoSidedIdeal.subset_span
  left
  use x,y
  left; rfl

/-- anti-commutation between annihilation operators -/
theorem ann_ann {α : Type} (x y : α) : ann x * ann y = -(ann y * ann x) := by
  apply eq_neg_iff_add_eq_zero.mpr
  rw[←RingHom.map_mul,←RingHom.map_mul,←RingHom.map_add,←(Ideal.Quotient.mk _).map_zero,
    Ideal.Quotient.mk_eq_mk_iff_sub_mem, sub_zero]
  apply TwoSidedIdeal.subset_span
  left
  use x,y
  right; left; rfl

/-- anti-commutation between creation and annihilation operators of different indices -/
theorem ann_cre_ne {α : Type} (x y : α) : x ≠ y → ann x * cre y = -(cre y * ann x) := by
  intro h
  apply eq_neg_iff_add_eq_zero.mpr
  rw[←RingHom.map_mul,←RingHom.map_mul,←RingHom.map_add, ←(Ideal.Quotient.mk _).map_zero,
    Ideal.Quotient.mk_eq_mk_iff_sub_mem, sub_zero]
  apply TwoSidedIdeal.subset_span
  left
  use x,y
  right; right; exact ⟨h, rfl⟩

/-- anti-commutation between creation and annihilation operators of same index -/
theorem ann_cre {α : Type} (x : α) :  ann x * cre x = 1 - (cre x * ann x) := by
  apply eq_sub_of_add_eq
  apply eq_of_sub_eq_zero
  rw[←RingHom.map_mul,←RingHom.map_mul,←RingHom.map_add,←(Ideal.Quotient.mk _).map_zero,
    ←(Ideal.Quotient.mk _).map_one,sub_eq_add_neg,←RingHom.map_neg,←RingHom.map_add,
    Ideal.Quotient.mk_eq_mk_iff_sub_mem, sub_zero,←sub_eq_add_neg]
  apply TwoSidedIdeal.subset_span
  right
  use x

abbrev Representation (α : Type) : Type := (Finset α →₀ ℝ) →ₗ[ℝ] (Finset α →₀ ℝ)

namespace Representation

noncomputable section

def commutator_sign {α : Type} [LinearOrder α] (s : Finset α) (a : α) : ℝ :=
  if Even (Finset.filter (· < a) s).card then 1 else -1

theorem commutator_sign_range {α : Type} [LinearOrder α] (s : Finset α) (a : α) :
    commutator_sign s a = 1 ∨ commutator_sign s a = -1 := by
  dsimp [commutator_sign]
  by_cases h : Even {x ∈ s | x < a}.card
  · simp[h]
  · simp[h]

theorem commutator_sign_diff {α : Type} [LinearOrder α] (s : Finset α) (a b : α) :
    commutator_sign (s \ {a}) b =
      if a < b ∧ a ∈ s then -commutator_sign s b else commutator_sign s b := by
  split
  · dsimp only [commutator_sign]
    rename_i h
    have : Finset.filter (· < b) s = (Finset.filter (· < b) (s \ {a})) ∪ {a} := by
      ext x
      constructor
      · simp +contextual [Classical.em]
      · simp 
        intro h'
        rcases h' with h' | h'
        · simp[h',h]
        · simp[h']
    have := congrArg Finset.card this
    rw[Finset.card_union, show {x ∈ s \ {a} | x < b} ∩ {a} = ∅ by simp,
       Finset.card_singleton, Finset.card_empty,Nat.sub_zero] at this
    rw[this]
    simp only [Nat.even_add_one]
    by_cases heven : Even {x ∈ s \ {a} | x < b}.card
    · simp[heven]
    · simp[heven]
  · rename_i h
    dsimp only [commutator_sign]
    have : Finset.filter (· < b) s = Finset.filter (· < b) (s \ {a}) := by   
      ext x
      simp
      intro  h₁ h₂ h₃
      exact h ⟨h₃ ▸ h₁, h₃ ▸ h₂⟩
    rw[this]

theorem commutator_sign_union {α : Type} [LinearOrder α] (s : Finset α) (a b : α) :
    commutator_sign (s ∪ {a}) b =
      if a < b ∧ a ∉ s then -commutator_sign s b else commutator_sign s b := by
  split
  · rename_i h
    dsimp only [commutator_sign]
    have : Finset.filter (· < b) (s ∪ {a}) = (Finset.filter (· < b) s) ∪ {a} := by
      ext x
      constructor
      · simp +contextual
      · simp
        intro h'
        rcases h' with h' | h'
        · simp[h',h]
        · simp[h']
    rw[this,Finset.card_union]
    have : {x ∈ s | x < b} ∩ {a} = (∅ : Finset α) := by
      ext x
      simp
      intro h₁ _ h₂
      exact h.2 (h₂ ▸ h₁)
    rw[this,Finset.card_empty,Finset.card_singleton,Nat.sub_zero]
    simp only [Nat.even_add_one]
    by_cases heven : Even ({x ∈ s | x < b}.card)
    · simp [heven]
    · simp [heven]
  · rename_i h
    dsimp only [commutator_sign]
    have : Finset.filter (· < b) s = Finset.filter (· < b) (s ∪ {a}) := by   
      ext x
      simp at h ⊢
      exact fun a b ↦ (b ▸ h) a
    rw[this]

def cre {α : Type} [LinearOrder α] (i : α) : Representation α where
  toFun x := {
    toFun s := if i ∉ s then 0 else x (s \ {i}) * commutator_sign s i
    support := Finset.image (fun s ↦ s ∪ {i}) (Finset.filter (i ∉ ·) x.support) 
    mem_support_toFun s := by
      simp [-Finset.union_singleton]
      constructor
      · intro ⟨s',⟨h₁,h₂⟩⟩
        split_ands
        · simp[←h₂]
        · simp[←h₂,-Finset.union_singleton] 
          rw[Finset.union_sdiff_cancel_right]
          · exact h₁.1
          · simp[h₁.2]
        rcases commutator_sign_range s i with h | h
        all_goals simp[h]
      intro ⟨h₁,h₂,_⟩
      use s \ {i}
      simpa[h₂,-Finset.union_singleton]
  }
  map_add' x y := by
    ext s
    simp[commutator_sign]
    split_ifs
    · rfl
    · rw[add_comm]
    · norm_num
  map_smul' m x := by
    ext s
    simp[commutator_sign]

def ann {α : Type} [LinearOrder α] (i : α) : Representation α where
  toFun x := {
    toFun s := if i ∈ s then 0 else x (s ∪ {i}) * commutator_sign s i
    support := Finset.image (fun s ↦ s \ {i}) (Finset.filter (i ∈ ·) x.support) 
    mem_support_toFun s := by
      simp[-Finset.union_singleton]
      constructor
      · intro ⟨a, ⟨h₁, h₂⟩, h₃⟩
        split_ands
        · simp[←h₃]
        · rwa[←h₃,Finset.sdiff_singleton_eq_erase,Finset.union_singleton,Finset.insert_erase h₂]
        · rcases commutator_sign_range s i with h | h
          all_goals simp[h]
      · intro ⟨h₁, h₂, _⟩
        use s ∪ {i}
        simp[h₂,-Finset.union_singleton]
        rw[Finset.union_sdiff_cancel_right]
        simpa
  }
  map_add' x y := by
    ext s
    simp[commutator_sign]
    split_ifs
    · norm_num
    · rfl
    · rw[add_comm]
  map_smul' m x := by
    ext s
    simp[commutator_sign]

def of₀ {α : Type} [LinearOrder α] : CreAnn α → Representation α
  | CreAnn.cre i => cre i
  | CreAnn.ann i => ann i

def of₁ {α : Type} [LinearOrder α] : FreeAlgebra ℝ (CreAnn α) →ₐ[ℝ] Representation α :=
  FreeAlgebra.lift ℝ of₀

theorem of₁_commutators {α : Type} [LinearOrder α] : ∀ x ∈ commutators α, of₁ x = 0 := by
  intro x h
  rcases h with ⟨a, b, h | h | h⟩ | ⟨a, h⟩
  · ext x s
    simp[of₁,h,of₀,cre,commutator_sign_diff]
    by_cases ha : a ∈ s
    · by_cases hb : b ∈ s
      · by_cases h : a < b
        · simp[h,ha,hb,h.ne,show b ≠ a from h.ne ∘ Eq.symm, show ¬(b < a) from h.asymm]
          conv =>
            lhs; arg 1
            rw[sdiff_sdiff_comm, mul_assoc, mul_comm (commutator_sign s b),←mul_assoc]
          exact neg_add_cancel _
        by_cases h' : a = b
        · simp[h']
        have h'' : b < a := lt_of_le_of_ne (le_of_not_gt h) (h' ∘ Eq.symm)
        simp[h,h',h'',ha,hb,show b ≠ a from h'∘Eq.symm]
        conv =>
          lhs; arg 1
          rw[sdiff_sdiff_comm, mul_assoc, mul_comm (commutator_sign s b),←mul_assoc]
        exact add_neg_cancel _
      · simp[ha,hb]
    · simp[ha]
  · ext x s
    simp[of₁,h,of₀,ann,-Finset.union_singleton,-Finset.singleton_union]
    by_cases ha : a ∈ s
    · simp[ha]
    by_cases hb : b ∈ s
    · simp[hb]
    by_cases h : a = b
    · simp[h]
    by_cases h' : a < b
    · simp[ha,hb,h,show b ≠ a from h ∘ Eq.symm, commutator_sign_union, -Finset.union_singleton,
           h',show ¬ b < a from h'.asymm,-Finset.singleton_union]
      ac_nf
      exact neg_add_cancel _
    have h'' : b < a := lt_of_le_of_ne (le_of_not_gt h') (h ∘ Eq.symm)
    simp[h,ha,hb,show b ≠ a from h ∘ Eq.symm, -Finset.union_singleton,-Finset.singleton_union,
         commutator_sign_union,h',h'']
    ac_nf
    exact neg_add_cancel _
  · ext x s
    simp[of₁,h.2,of₀,cre,ann,-Finset.union_singleton,-Finset.singleton_union]
    by_cases ha : a ∈ s
    · simp[ha,h.1]
    by_cases hb : b ∈ s
    · simp[ha,hb,h.1,-Finset.union_singleton,-Finset.singleton_union,
           commutator_sign_union,commutator_sign_diff]
      have : (s ∪ {a}) \ {b} = (s \ {b} ∪ {a}) := by
        ext x
        constructor
        · simp +contextual
        · simp
          intro h''
          rcases h'' with h'' | h''
          · exact ⟨Or.inl h'', h'' ▸ h.1⟩
          · exact ⟨Or.inr h''.1, h''.2⟩
      by_cases h' : a < b
      · simp[h',show ¬ b < a from h'.asymm,-Finset.union_singleton]
        rw[this]
        ring
      have h'' : b < a := lt_of_le_of_ne (le_of_not_gt h') (h.1 ∘ Eq.symm)
      simp[h',h'',-Finset.union_singleton]
      rw[this]
      ring
    · simp[ha,hb,show b ≠ a from h.1 ∘ Eq.symm]
  · ext x s
    simp[of₁,h,of₀,cre,ann,-Finset.union_singleton,-Finset.singleton_union]
    have : commutator_sign s a * commutator_sign s a = 1 := by
      by_cases h : Even {x ∈ s | x < a}.card
      · simp[commutator_sign,h]
      · simp[commutator_sign,h]
    by_cases ha : a ∈ s
    · simp[ha,commutator_sign_diff]
      rw[mul_assoc,this,mul_one,sub_self]
    simp[ha,-Finset.union_singleton,commutator_sign_union]
    rw[Finset.union_sdiff_cancel_right,mul_assoc,this,mul_one,sub_self]
    simpa


def of {α : Type} [LinearOrder α] : Operator α →ₐ[ℝ] Representation α :=
  Ideal.Quotient.liftₐ _ of₁ (by
    intro a h
    rw[←TwoSidedIdeal.mem_ker]
    rw[TwoSidedIdeal.mem_asIdeal] at h
    suffices final : TwoSidedIdeal.span (commutators α) ≤ TwoSidedIdeal.ker of₁ from final h
    rw[TwoSidedIdeal.span_le]
    intro x h
    simp[TwoSidedIdeal.ker]
    exact of₁_commutators x h
  )

end

end Representation

/-- 1 ≠ 0 for `Operator` -/
instance instNeZeroOne {α : Type} [LinearOrder α] : NeZero (1 : Operator α) where
  out := by
    intro h
    have repr0 : Representation.of (0 : Operator α) = 0 := by simp[Representation.of]
    have repr1 : Representation.of (1 : Operator α) = 1 := by simp[Representation.of]
    replace h := repr0 ▸ repr1 ▸ (congrArg Representation.of h)
    simp at h

/-- The injectivity of `cre` -/
theorem cre_inj {α : Type} [LinearOrder α] : Function.Injective (@cre α) := by
  intro x y h
  by_contra! hc
  have := (ann_cre _) ▸ h ▸ (ann_cre_ne _ _ hc)
  rw[sub_eq_iff_eq_add,neg_add_cancel] at this
  simp at this

/-- The injectivity of `ann` -/
theorem ann_inj {α : Type} [LinearOrder α] : Function.Injective (@ann α) := by
  intro x y h
  by_contra! hc
  have := (ann_cre _) ▸ h ▸ (ann_cre_ne _ _ hc)
  rw[sub_eq_iff_eq_add,neg_add_cancel] at this
  simp at this

namespace conjugation

def conj₀ {α : Type} : CreAnn α → CreAnn α
  | CreAnn.cre x => CreAnn.ann x
  | CreAnn.ann x => CreAnn.cre x

lemma conj₀_involutive {α : Type} : ∀ x : CreAnn α, conj₀ (conj₀ x) = x
  | CreAnn.cre x => by simp only [conj₀]
  | CreAnn.ann x => by simp only [conj₀]

def conj₁ {α : Type} : (FreeAlgebra ℝ (CreAnn α)) →ₐ[ℝ] (FreeAlgebra ℝ (CreAnn α))ᵐᵒᵖ :=
  FreeAlgebra.lift ℝ (MulOpposite.op ∘ FreeAlgebra.ι ℝ ∘ conj₀)

def conj₂ {α : Type} : (FreeAlgebra ℝ (CreAnn α)) → Operator α :=
  Ideal.Quotient.mk _ ∘ MulOpposite.unop ∘ conj₁

/-- The conjugation of operators -/
def conj {α : Type} : Operator α → Operator α :=
  Quotient.lift conj₂ (by
    intro a b h
    rw[←Quotient.eq_iff_equiv] at h
    have : (Ideal.Quotient.mk _ a : Operator α) = Ideal.Quotient.mk _ b := by
      simpa [←Ideal.Quotient.mk_eq_mk, Submodule.Quotient.mk]
    simp only [conj₂,Function.comp_apply,Ideal.Quotient.mk_eq_mk_iff_sub_mem] at this ⊢
    rw [←MulOpposite.unop_sub, ←map_sub]
    rw [TwoSidedIdeal.mem_asIdeal] at this
    generalize a - b = x at this ⊢
    refine TwoSidedIdeal.span_induction ?_ ?_ ?_ ?_ ?_ ?_ this
    · intro x h
      rw [TwoSidedIdeal.mem_asIdeal]
      apply TwoSidedIdeal.subset_span
      rcases h with h | h
      · rcases h with ⟨a, b, h | h | h⟩
        · simp[h,conj₁,conj₀]; left; use b,a; right; left; rfl
        · simp[h,conj₁,conj₀]; left; use b,a; left; rfl
        · simp[h.2,conj₁,conj₀]; left; use b,a; right; right; exact ⟨h.1.symm, rfl⟩
      obtain ⟨a, h⟩ := h
      simp[h, conj₁, conj₀]; right; use a
    · simp only [map_zero, MulOpposite.unop_zero, zero_mem]
    · intro x y _ _ h₁ h₂
      rw[map_add,MulOpposite.unop_add]
      exact Ideal.add_mem _ h₁ h₂
    · intros
      rwa[map_neg,MulOpposite.unop_neg,Ideal.neg_mem_iff]
    · intro x y _ h
      rw[map_mul,MulOpposite.unop_mul]
      exact TwoSidedIdeal.mul_mem_right _ _ _ h
    · intro x y _ h
      rw[map_mul,MulOpposite.unop_mul]
      exact TwoSidedIdeal.mul_mem_left _ _ _ h
  )

theorem mk_eq_mk {α : Type} (a : FreeAlgebra ℝ (CreAnn α)) :
    (Ideal.Quotient.mk _ a: Operator α) = ⟦a⟧ := rfl

set_option synthInstance.maxHeartbeats 30000 in 
-- This is needed otherwise lean will fail to synthesize AddHomClass for Ideal.Quotient.mk
instance operatorStarRing (α : Type) : StarRing (Operator α) where
  star := conj
  star_involutive x := by
    refine Submodule.Quotient.induction_on _ x ?_
    intro x
    rw[Submodule.Quotient.mk]
    simp[conj,conj₂,←Ideal.Quotient.mk_eq_mk,Submodule.Quotient.mk]
    congr 1
    refine FreeAlgebra.induction _ _ ?_ ?_ ?_ ?_ x
    · simp
    · simp[conj₁,conj₀_involutive]
    · simp +contextual
    · simp +contextual
  star_add := by
    apply Quotient.ind₂
    intro a b
    rw[←mk_eq_mk,←mk_eq_mk,←map_add,mk_eq_mk,mk_eq_mk, mk_eq_mk]
    simp [conj,Quotient.lift_mk,conj₂]
  star_mul := by
    apply Quotient.ind₂
    intro a b
    rw [←mk_eq_mk,←mk_eq_mk,←map_mul,mk_eq_mk,mk_eq_mk, mk_eq_mk,
      conj,Quotient.lift_mk,Quotient.lift_mk,Quotient.lift_mk]
    simp[conj₂]

end conjugation

open conjugation in
/-- the conjugation of `cre x` is `ann x` -/
theorem star_cre {α : Type} (x : α) : star (cre x) = ann x := by
  simp[star,conj,mk_eq_mk,conj₂,conj₁,conj₀]

open conjugation in
/-- the conjugation of `ann x` is `cre x` -/
theorem star_ann {α : Type} (x : α) : star (ann x) = cre x := by
  simp[star,conj,mk_eq_mk,conj₂,conj₁,conj₀]

def vacuum_ideal {α : Type} : Ideal (Operator α) := Ideal.span (Set.range ann)

end Fock

abbrev Fock (α : Type) : Type := Fock.Operator α ⧸ Fock.vacuum_ideal

namespace Fock

def vacuum_submodule {α : Type} : Submodule ℝ (Operator α) := vacuum_ideal.restrictScalars _

set_option synthInstance.maxHeartbeats 30000 in
-- This is needed otherwise lean will fail to synthesize AddHomClass for Ideal.Quotient.mk
/-- `star` as a linear map -/
def starₗ {α : Type} : Operator α →ₗ[ℝ] Operator α where
  toFun := star
  map_add' x y := by simp
  map_smul' m := by
    apply Quotient.ind
    intro a
    rw[←conjugation.mk_eq_mk,←Ideal.Quotient.mkₐ_eq_mk ℝ, ←map_smul,Ideal.Quotient.mkₐ_eq_mk,
      conjugation.mk_eq_mk,conjugation.mk_eq_mk,RingHom.id_apply]
    simp[star,conjugation.conj,conjugation.conj₂]
    rw[←Ideal.Quotient.mkₐ_eq_mk ℝ,map_smul]
    
def co_vacuum_submodule {α : Type} : Submodule ℝ (Operator α) :=
  Submodule.map starₗ vacuum_submodule

abbrev vacuum_expectation (α : Type) : Type :=
  Operator α ⧸ (vacuum_submodule ⊔ co_vacuum_submodule)

namespace Operator

abbrev ofReal {α : Type} : ℝ →+* Operator α :=
  (Ideal.Quotient.mk _).comp (algebraMap ℝ (FreeAlgebra ℝ (CreAnn α)))

end Operator

namespace vacuum_expectation

def mk {α : Type} : Operator α → vacuum_expectation α := Submodule.Quotient.mk

open Classical
in noncomputable def expect {α : Type} : Representation α →ₗ[ℝ] ℝ where
  toFun x := x (Finsupp.single ∅ 1) ∅
  map_add' x y := by simp
  map_smul' m x := by simp

end vacuum_expectation

noncomputable def vacExpect {α : Type} [LinearOrder α] : Operator α →ₗ[ℝ] ℝ :=
  vacuum_expectation.expect.comp Representation.of.toLinearMap

theorem vacExpect_ofReal {α : Type} [LinearOrder α] (x : ℝ) :
    vacExpect (Operator.ofReal (α := α) x) = x := by
  simp[vacExpect,vacuum_expectation.expect]

theorem vacExpect_mul_ann {α : Type} [LinearOrder α] (x : Operator α) (a : α) :
    vacExpect (x * ann a) = 0 := by
  simp[vacExpect,vacuum_expectation.expect]
  open Representation in conv =>
    lhs; arg 1; arg 2
    simp[of,of₁,of₀]
  have : ((Representation.ann a) (Finsupp.single ∅ 1)) = 0 := by
    ext s
    simp[Representation.ann]
  simp[this]

theorem vacExpect_cre_mul {α : Type} [LinearOrder α] (x : Operator α) (a : α) :
    vacExpect (cre a * x) = 0 := by
  simp[vacExpect,vacuum_expectation.expect]
  open Representation in conv =>
    lhs; arg 1
    simp[of,of₁,of₀,Representation.cre]
  simp

namespace Operator

noncomputable abbrev toFockRepresentation {α : Type} [LinearOrder α] :
    Operator α →ₗ[ℝ] (Finset α →₀ ℝ) where
  toFun x := Representation.of x (Finsupp.single ∅ 1)
  map_add' x y := by simp
  map_smul' x y := by simp

end Operator

theorem vacExpect_star_mul {α : Type} [LinearOrder α] (x y : Operator α) :
  vacExpect (star x * y) = (x.toFockRepresentation * y.toFockRepresentation).sum fun _ a ↦ a := by
    sorry


/-
open Classical
in def of₀ {α : Type} [LinearOrder α] : Operator α →ₗ[ℝ] FockRepresentation α where
  toFun x := Representation.of x fun s ↦ if s = ∅ then 1 else 0
  map_add' x y := by simp
  map_smul' a x := by simp
-/


notation (name := R3) "ℝ³" => Fin 3 → ℝ

noncomputable def fieldOp {α : Type} (basis : α → ℝ³ → ℝ) : ℝ³ → Operator α :=
  fun x ↦ ∑ᶠ a : α, basis a x • cre a

--def waveFunction {α : Type} (basis : α → ℝ³ → ℝ)

theorem vecExpect_sound {α : Type} [LinearOrder α] (x : Operator α) :
    vacuum_expectation.mk (Operator.ofReal <| vacExpect x) = vacuum_expectation.mk x := by sorry

end Fock
